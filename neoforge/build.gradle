plugins {
    id 'net.neoforged.moddev'
}

configurations {
    runtimeClasspath.extendsFrom localRuntime
}

dependencies {
    compileOnly project(':common')

    implementation "com.teamresourceful.resourcefulconfig:resourcefulconfig-neoforge-${project.resourceful_config_minecraft_version}:${project.resourceful_config_version}"
}

publishMods {
    file = tasks.jar.archiveFile
    modLoaders.add("neoforge")

    def uploadDependenciesCf = [
            '714059': true // resourceful config
    ]
    def uploadDependenciesMr = [
            'M1953qlQ': true // resourceful config
    ]

    if (project.hasProperty('curseforge_id')) {
        curseforge('CurseforgeNeo') {

            accessToken = providers.environmentVariable('CURSEFORGEKEY')
            projectId = project.findProperty('curseforge_id')
            minecraftVersions.add(project.minecraft_version)

            uploadDependenciesCf.each { dep, required ->
                if (required) {
                    requires(dep)
                } else {
                    optional(dep)
                }
            }
        }
    }

    if (project.hasProperty('modrinth_id')) {
        modrinth('modrinthNeo') {
            accessToken = accessToken = providers.environmentVariable('MODRINTH_TOKEN')
            projectId = project.findProperty('modrinth_id')
            minecraftVersions.add(project.minecraft_version)

            dependencies {
                uploadDependenciesMr.each { dep, required ->
                    if (required) {
                        requires(dep)
                    } else {
                        optional(dep)
                    }
                }
            }
        }
    }
}

neoForge {
    version = project.neoforge_version

    parchment {
        minecraftVersion = project.parchment_minecraft_version
        mappingsVersion = project.parchment_mappings_version
    }

    def atFile = project(":common").file("src/main/resources/META-INF/accesstransformer.cfg")
    if (atFile.exists()) {
        accessTransformers {
            from atFile
            publish atFile
        }
    }

    validateAccessTransformers.set(true)

    mods {
        // define mod <-> source bindings
        // these are used to tell the game which sources are for which mod
        // mostly optional in a single mod project
        // but multi mod projects should define one per mod
        "${mod_id}" {
            sourceSet(sourceSets.main)
            sourceSet(project(":common").sourceSets.main)
        }
    }

    runs {
        configureEach {
            logLevel = org.slf4j.event.Level.DEBUG
            systemProperty 'forge.logging.markers', 'REGISTRIES'

            gameDirectory = project.file('run')

            sourceSet = sourceSets.main
            loadedMods.set([mods."${mod_id}"])
        }

        client {
            client()
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id

            if (project.hasProperty('mc_uuid')) {
                programArguments.add("--uuid=${project.findProperty('mc_uuid')}")
            }

            if (project.hasProperty('mc_username')) {
                programArguments.add("--username=${project.findProperty('mc_username')}")
            }

            if (project.hasProperty('mc_java_agent_path')) {
                jvmArgument("-javaagent:${project.findProperty('mc_java_agent_path')}")
            }
        }

        server {
            server()
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
            programArguments.add('--nogui')
        }
    }
}

tasks.named("compileJava", JavaCompile) {
    source(project(":common").sourceSets.main.allJava)
}

tasks.named("javadoc", Javadoc) {
    source(project(":common").sourceSets.main.allJava)
}

tasks.named("sourcesJar", Jar) {
    from(project(":common").sourceSets.main.allSource)
}

processResources {
    from project(":common").sourceSets.main.resources
}
